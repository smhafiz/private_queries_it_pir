// This file is part of BarrettCUDA v0.1.
// 
// BarrettCUDA is a fast(ish) implementation of finite field sparse
// matrix-vector multiplication (SpMV) for Nvidia GPU devices, written
// in CUDA C++. BarrettCUDA supports SpMV for matrices expressed in
// the 'compressed column storage' (CCS) sparse matrix representation
// over (i) the field of integers modulo an arbitrary multi-precision
// prime, or (ii) either of the binary fields GF(2^8) or GF(2^16).
// 
// Copyright (C) 2016, Ryan Henry and Syed Mahbub Hafiz.
// 
// BarrettCUDA is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published
// by the Free Software Foundation, either version 3 of the License,
// or (at your option) any later version.
// 
// BarrettCUDA is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with BarrettCUDA. If not, see <http://www.gnu.org/licenses/>.

#include <string.h>
#include <iostream>
#include <sstream>
#include <vector>
#include <chrono>
#include <stdio.h>
#include <stdlib.h>

#define BITS_PER_LIMB	(sizeof(uint) * 8)
#define BITS_IN(limbs)	((limbs) * BITS_PER_LIMB)

typedef unsigned int uint;

using namespace std;

static const char coords []  = { 'x', 'y', 'z', 'w' };

char * r0;
char * r1;
char * r2;
char * r3;

/// get_q

#define LO 			0
#define HI 			1

#define CARRY 			1
#define MUL			2
#define MADC 			3

#define CARRY_IN(i)		(state[i] |= CARRY)
#define MUL_IN(i)		(state[i] |= MUL)

#define IS_OCCUPIED(i)		(state[i] & MADC ? true : false)
#define DO_CARRY_OUT(i)		(state[i] & MUL ? true : false)
#define CARRY_OUT_FLAG(i)	(DO_CARRY_OUT(i) ? ".cc" : "")
#define CARRY_IN_FLAG(b)	(b ? "c" : "")
#define LO_OR_HI(p)		(p.first == HI ? ".hi" : ".lo")

#define GET_DEST_REG_Q(i)  	((i+1) % (limbs+1))// ((i + limbs - 3) % (2 * limbs - 3))
//#define GET_DEST_REG(i)  	(i < limbs-1 ? i+2 : i-limbs+1)//(i < limbs-1 ? limbs+i-1 : i-1)
#define GET_FIRST_REG_Q(p)	(limbs+1+p.second)//(2*limbs-3+p.second)//(2*limbs-1+p.second)
#define GET_SECOND_REG_Q(i,p)	(2*limbs+1+i-p.second-p.first)//(3*limbs-3+i-p.second-p.first)//(3*limbs-1+i-p.second-p.first)
/// end get_q

#define NUM_TMP_REGS        (((limbs-1)%3) > 0 ? ((limbs-1)/3)+1:((limbs-1)/3))
//#define GET_DEST_REG(i)   (i < limbs-1 ? i+2 : i-limbs+1)//(i < limbs-1 ? limbs+i-1 : i-1)
#define GET_DEST_REG_Q(i)   ((i+NUM_TMP_REGS) % (limbs+NUM_TMP_REGS))// ((i + limbs - 3) % (2 * limbs - 3))
#define GET_FIRST_REG_Q(p)  (limbs+NUM_TMP_REGS+p.second)//(2*limbs-3+p.second)//(2*limbs-1+p.second)
#define GET_SECOND_REG_Q(i,p)   (2*limbs+NUM_TMP_REGS+i-p.second-p.first)//(3*limbs-3+i-p.second-p.first)//(3*limbs-1+i-p.second-p.first)
/// end get_q

#define GET_FIRST_REG_R(p)	(limbs+p.second)
#define GET_SECOND_REG_R(i,p)	(2*limbs+i-p.second-p.first)



void wrap(const char * str, int width = 70, const char * afternl = "\t  ")
{
    std::stringstream buf;

    int last_space = width - 1;
    for (int i = 0; i < strlen(str); ++i)
    {
	int j = 0;
	for (j = 0; j < width; j++)
	{
	    last_space = isspace(str[i + j]) ? i+j : last_space;
	}
	last_space = (i+j < strlen(str)) ? last_space : strlen(str);
	buf << std::string(str, i, last_space-i);
	if (last_space < strlen(str)) buf << "\n" << afternl;
	i = last_space;
    }
    cout << buf.str().c_str();
}

static void print_license()
{
    cout << "// This file was generated by BarrettCUDA v0.1.\n" \
	    "// \n" \
	    "// BarrettCUDA is a fast(ish) implementation of finite field sparse\n" \
	    "// matrix-vector multiplication (SpMV) for Nvidia GPU devices, written\n" \
	    "// in CUDA C++. BarrettCUDA supports SpMV for matrices expressed in\n" \
	    "// the 'compressed column storage' (CCS) sparse matrix representation\n" \
	    "// over (i) the field of integers modulo an arbitrary multi-precision\n" \
	    "// prime, or (ii) either of the binary fields GF(2^8) or GF(2^16).\n" \
	    "// \n" \
	    "// Copyright (C) 2016, Ryan Henry and Syed Mahbub Hafiz.\n" \
	    "// \n" \
	    "// BarrettCUDA is free software: you can redistribute it and/or modify\n" \
	    "// it under the terms of the GNU General Public License as published\n" \
	    "// by the Free Software Foundation, either version 3 of the License,\n" \
	    "// or (at your option) any later version.\n" \
	    "// \n" \
	    "// BarrettCUDA is distributed in the hope that it will be useful,\n" \
	    "// but WITHOUT ANY WARRANTY; without even the implied warranty of\n" \
	    "// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n" \
	    "// GNU General Public License for more details.\n" \
	    "// \n" \
	    "// You should have received a copy of the GNU General Public License\n" \
	    "// along with BarrettCUDA. If not, see <http://www.gnu.org/licenses/>.\n\n";
}

static void print_uint(uint limbs)
{
    /// output the uintX struct
    cout << "struct uint" << BITS_IN(limbs) << "\n";
    cout << "{\n";
    int i;
    for (i = 0; i < limbs - 3; i += 4)
    {
	cout << "    uint128 w" << i << "; \t\t\t\t// limbs " << i << " to " << (i+3) << "\n";
    }
    int rem = BITS_IN(limbs % 4);
    if (rem) cout << "    uint" << rem << "  w" << i << "; \t\t\t\t// limbs " << i << " to " << (limbs - 1) << "\n";
    cout << "};\n\n";
}

static void print_to_ZZ(uint limbs)
{
    /// output to_ZZ (converts a uintX to a ZZ)
    cout << "static inline NTL::ZZ to_ZZ(const uint" << BITS_IN(limbs) <<  " & n)\n";
    cout << "{\n";
    cout << "    return to_ZZ<uint" << BITS_IN(limbs) << ">(n);\n";
    cout << "}\n\n";
}

static void print_make_uint(uint limbs)
{
    cout << "static inline uint" << BITS_IN(limbs) << " make_uint" << BITS_IN(limbs) << "(const uint w0x";
    for (int i = 1; i < limbs; i++)
    {
	sprintf(r0, "w%u%c", i/4, coords[i%4]);
	cout << ", const uint " << r0;
    }
    cout << ")\n{\n";
    cout << "    uint" << BITS_IN(limbs) << " res;\n\n";
    cout << "    uint * _res = (uint *)&res;\n";
    for (int i = 0; i < limbs; ++i)
    {
	sprintf(r0, "w%u%c", i/4, coords[i%4]);
	printf("    _res[%u]=%4s;\t\t\t\t// res.w%u.%c=%4s\n", i, r0, i/4, coords[i%4], r0);
	//cout << "    _res[" << i << "]=w" << i << ";\t\t\t\t\t// res.w" << (i/4) << "." << coords[i%4] << "=w"\n";
    }
    cout << "\n    return res;\n";
    cout << "}\n\n";
}

static void print_to_ZZ_p(uint limbs)
{
    /// output to_ZZ_p (converts a uintX to a ZZ_p)
    cout << "static inline NTL::ZZ_p to_ZZ_p(const uint" << BITS_IN(limbs) <<  " & n)\n";
    cout << "{\n";
    cout << "    return NTL::to_ZZ_p(to_ZZ<uint" << BITS_IN(limbs) << ">(n));\n";
    cout << "}\n\n";
}

static void print_to_uint(uint limbs)
{
    /// output to_uintX (converts a ZZ to a uintX)
    cout << "static inline void to_uint" << BITS_IN(limbs) << "(const NTL::ZZ & n, uint" << BITS_IN(limbs) << " & ret)\n";
    cout << "{\n";
    cout << "    to_uint<uint" << BITS_IN(limbs) << ">(n, ret);\n";
    cout << "}\n\n";
}

static std::string print_w(uint limbs, uint index)
{
	if(limbs <= 4) 
	{
		return "";
	} else 
	{
		return ".w" +  std::to_string((index/4)*4);
	}
}

static std::string print_coords(uint limbs, uint index)
{
	if( limbs%4 == 1 && index == limbs - 1) 
	{
		return "";
	} else 
	{	stringstream ss;
		ss << "." << coords[index%4];
		return ss.str();
	}
}

static void print_normalize(uint limbs)
{
    cout << "__device__ __forceinline__ void normalize(uint" << BITS_IN(limbs) << " & a_lo, uint" << BITS_IN(limbs) << " & a_hi,\n\tconst uint" << BITS_IN(limbs) << " & s_lo, const uint s_hi)\n";
    cout << "{\n";
    /*cout << "    uint * _a_lo = (uint *)&a_lo;\n";
    cout << "    uint * _a_hi = (uint *)&a_hi;\n";
    cout << "    const uint * _s_lo = (uint *)&s_lo;\n";*/
    sprintf(r0, "%%%u", 0);
    sprintf(r2, "%%%u", 2 * limbs);
    printf("    asm(\"sub.cc.u32\t%3s,%3s,%3s;\\n\\t\"", r0, r0, r2);
    printf("\t// r0-=%3s\n", &(*r2='r'));
    for (int i = 1; i < 2 * limbs - 1; ++i)
    {
	sprintf(r0, "%%%u", i);
	sprintf(r2, "%%%u", (i > limbs) ? 3 * limbs : 2 * limbs + i);
	printf("\t\"subc.cc.u32\t%3s,%3s,%3s;\\n\\t\"", r0, r0, r2);
	printf("\t//%3s-=(%3s+c)\n", &(*r0='r'), &(*r2='r'));
    }
    sprintf(r0, "%%%u", 2 * limbs - 1);
    sprintf(r2, "%%%u", 3 * limbs);
    printf("\t\"subc.u32\t%3s,%3s,%3s;\\n\\t\"", r0, r0, r2);
    printf("\t//%3s-=(%3s+c)\n", &(*r0='r'), &(*r2='r'));
    
    /*std::stringstream iregs;
    iregs << "\t: \"+r\"(_a_lo[0])";
    for (int i = 1; i < limbs; i++) iregs << ", \"+r\"(_a_lo[" << i << "])";
    for (int i = 0; i < limbs; i++) iregs << ", \"+r\"(_a_hi[" << i << "])";
    wrap(iregs.str().c_str());*/

    std::stringstream iregs2;
    iregs2 << "\t: \"+r\"(a_lo"<< print_w(limbs, 0)<<".x)";
    for (int i = 1; i < limbs; i++) iregs2 << ", \"+r\"(a_lo" << print_w(limbs, i) << print_coords(limbs, i) <<")";
    for (int i = 0; i < limbs; i++) iregs2 << ", \"+r\"(a_hi" << print_w(limbs, i) << print_coords(limbs, i) <<")";
    wrap(iregs2.str().c_str());

    /*std::stringstream oregs;
    oregs << "\n\t: \"r\"(_s_lo[0])";
    for (int i = 1; i < limbs; i++) oregs << ", \"r\"(_s_lo[" << i << "])";
    oregs << ", \"r\"(s_hi));\n";
    wrap(oregs.str().c_str());
    cout << "}\n\n";*/

    std::stringstream oregs2;
    oregs2 << "\n\t: \"r\"(s_lo"<< print_w(limbs, 0)<<".x)";
    for (int i = 1; i < limbs; i++) oregs2 << ", \"r\"(s_lo" << print_w(limbs, i) << print_coords(limbs, i) <<")";
    oregs2 << ", \"r\"(s_hi));\n";
    wrap(oregs2.str().c_str());
    cout << "}\n\n";
}

static void print_sub(uint limbs)
{
    cout << "__device__ __forceinline__ uint sub(uint" << BITS_IN(limbs) << " & a_lo, uint" << BITS_IN(limbs) << " & a_hi,\n\tconst uintXp<uint" << BITS_IN(limbs) << "> & r)\n";
    cout << "{\n";
    /*cout << "    uint * _a_lo = (uint *)&a_lo;\n";
    cout << "    uint * _a_hi = (uint *)&a_hi;\n";
    cout << "    const uint * _r = (uint *)&r;\n";*/
    sprintf(r0, "%%%u", 0);
    sprintf(r2, "%%%u", limbs + 1);
    printf("    asm(\"sub.cc.u32\t%3s,%3s,%3s;\\n\\t\"", r0, r0, r2);
    printf("\t// r0-=%3s\n", &(*r2='r'));
    for (int i = 1; i < limbs; ++i)
    {
	sprintf(r0, "%%%u", i);
	sprintf(r2, "%%%u", limbs + i + 1);
	printf("\t\"subc.cc.u32\t%3s,%3s,%3s;\\n\\t\"", r0, r0, r2);
	printf("\t//%3s-=(%3s+c)\n", &(*r0='r'), &(*r2='r'));
    }
    sprintf(r0, "%%%u", limbs);
    sprintf(r2, "%%%u", 2 * limbs+1);
    printf("\t\"subc.u32\t%3s,%3s,%3s;\\n\\t\"", r0, r0, r2);
    printf("\t//%3s-=(%3s+c)\n", &(*r0='r'), &(*r2='r'));

    /*std::stringstream iregs;
    iregs << "\t: \"+r\"(_a_lo[0])";
    for (int i = 1; i < limbs; i++) iregs << ", \"+r\"(_a_lo[" << i << "])";
    iregs << ", \"+r\"(_a_hi[0])";
    wrap(iregs.str().c_str());*/

    std::stringstream iregs2;
    iregs2 << "\t: \"+r\"(a_lo"<< print_w(limbs, 0)<<".x)";
    for (int i = 1; i < limbs; i++) iregs2 << ", \"+r\"(a_lo" << print_w(limbs, i) << print_coords(limbs, i) <<")";
    iregs2 << ", \"+r\"(a_hi"<< print_w(limbs, 0)<<".x)";
    wrap(iregs2.str().c_str());

    /*std::stringstream oregs;
    oregs << "\n\t: \"r\"(_r[0])";
    for (int i = 1; i < limbs + 1; i++) oregs << ", \"r\"(_r[" << i << "])";
    oregs << ");\n";
    wrap(oregs.str().c_str());
    cout << "    return _a_hi[0];\n";
    cout << "}\n\n";*/

    std::stringstream oregs2;
    oregs2 << "\n\t: \"r\"(r.lo"<< print_w(limbs, 0)<<".x)";
    for (int i = 1; i < limbs; i++) oregs2 << ", \"r\"(r.lo" << print_w(limbs, i) << print_coords(limbs, i) <<")";
    oregs2 << ", \"r\"(r.hi)";
    oregs2 << ");\n";
    wrap(oregs2.str().c_str());
    cout << "    return a_hi"<< print_w(limbs, 0)<<".x;\n";
    cout << "}\n\n";
}

static void print_sub_modulus(uint limbs)
{
    cout << "__device__ __forceinline__ void sub_modulus(uintXp<uint" << BITS_IN(limbs) << "> & r, const uint" << BITS_IN(limbs) << " & m)\n";
    cout << "{\n";
    sprintf(r0, "%%%u", 0);
    sprintf(r2, "%%%u", limbs + 1);
    printf("    asm(\"sub.cc.u32\t%3s,%3s,%3s;\\n\\t\"", r0, r0, r2);
    printf("\t// r0-=%3s\n", &(*r2='r'));
    for (int i = 1; i < limbs; ++i)
    {
	sprintf(r0, "%%%u", i);
	sprintf(r2, "%%%u", limbs + i + 1);
	printf("\t\"subc.cc.u32\t%3s,%3s,%3s;\\n\\t\"", r0, r0, r2);
	printf("\t//%3s-=(%3s+c)\n", &(*r0='r'), &(*r2='r'));
    }
    sprintf(r0, "%%%u", limbs);
    //sprintf(r2, "%%%u", 2 * limbs+1);
    //printf("\t\"subc.u32\t%3s,%3s,%3s;\\n\\t\"", r0, r0, r2);
    printf("\t\"subc.u32\t%3s,%3s,  0;\\n\\t\"", r0, r0);
    printf("\t//%3s-=(    c)\n", &(*r0='r'));

    /*std::stringstream iregs;
    iregs << "\t: \"+r\"(_a_lo[0])";
    for (int i = 1; i < limbs; i++) iregs << ", \"+r\"(_a_lo[" << i << "])";
    iregs << ", \"+r\"(_a_hi[0])";
    wrap(iregs.str().c_str());*/

    std::stringstream iregs2;
    iregs2 << "\t: \"+r\"(r.lo"<< print_w(limbs, 0)<<".x)";
    for (int i = 1; i < limbs; i++) iregs2 << ", \"+r\"(r.lo" << print_w(limbs, i) << print_coords(limbs, i) <<")";
    iregs2 << ", \"+r\"(r.hi)";
    wrap(iregs2.str().c_str());



    std::stringstream oregs2;
    oregs2 << "\n\t: \"r\"(m"<< print_w(limbs, 0)<<".x)";
    for (int i = 1; i < limbs; i++) oregs2 << ", \"r\"(m" << print_w(limbs, i) << print_coords(limbs, i) <<")";
    oregs2 << ");\n";
    wrap(oregs2.str().c_str());
    cout << "}\n\n";
}

static void print_mad(uint limbs)
{
    vector< vector<int> > col(2 * limbs);
    for (int i = 0; i < limbs; ++i)
    {
	for (int j = limbs - 1; j >= 0; --j) col[i + j].push_back(i);
    }
    
    cout << "__device__ __forceinline__ void mad(uint" << BITS_IN(limbs) << " & a_lo, uint" << BITS_IN(limbs) << " & a_hi,\n\tuint & overflow, const uint" << BITS_IN(limbs) << " & b, const uint" << BITS_IN(limbs) << " & c)\n";
    cout << "{\n";
    /*cout << "    uint * _a_lo = (uint *)&a_lo;\n";
    cout << "    uint * _a_hi = (uint *)&a_hi;\n";
    cout << "    const uint * _b = (uint *)&b;\n";
    cout << "    const uint * _c = (uint *)&c;\n\n";*/
    cout << "    asm(";
    int curr = 0;
    while (curr < 2 * limbs)
    {
	while (col[curr].empty()) { ++curr; }
	bool carry = false;
	for (int i = curr; i < 2 * limbs; )
	{
	    if (col[i].empty())
	    {
		sprintf(r0, "%%%u", i);
		printf("\"addc.cc.u32\t%3s,%3s,  0    ;\\n\\t\"", r0, r0);
		printf("\t//%3s+=c\n\t", &(*r0='r'));
		i++;
	    }
	    else
	    {
		sprintf(r0, "%%%u", i);
		sprintf(r1, "%%%u", col[i].back() + 2 * limbs + 1);
		sprintf(r2, "%%%u", i - col[i].back() + 3 * limbs + 1);
		sprintf(r3, "%%%u", i+1);
		printf("\"mad%s.lo.cc.u32\t%3s,%3s,%3s,%3s;\\n\\t\"", (carry ? "c" : ""), r0, r1, r2, r0);
		printf("\t//%3s+=[%3s*%3s].lo%s\n\t", &(*r0='r'), &(*r1='r'), &(*r2='r'), (carry ? "+c" : "  "));
		printf("\"madc.hi.cc.u32\t%3s,%3s,%3s,%3s;\\n\\t\"", r3, &(*r1='%'), &(*r2='%'), r3);
		printf("\t//%3s+=[%3s*%3s].hi%s\n\t", &(*r3='r'), &(*r1='r'), &(*r2='r'), (carry ? "+c" : "  "));
		carry = true;
		col[i].pop_back();
		i += 2;
	    }
	}
	if (curr < 2 * limbs)
	{
	    sprintf(r0, "%%%u", 2 * limbs);
	    printf("\"addc.u32\t%3s,%3s,  0    ;\\n\\t\"", r0, r0);
	    printf("\t//%3s+=c\n\t", &(*r0='r'));
	}
    }
    /*std::stringstream iregs;
    iregs << ": \"+r\"(_a_lo[0])";
    for (int i = 1; i < limbs; i++) iregs << ", \"+r\"(_a_lo[" << i << "])";
    for (int i = 0; i < limbs; i++) iregs << ", \"+r\"(_a_hi[" << i << "])";
    iregs << ", \"+r\"(overflow)";
    wrap(iregs.str().c_str());*/

    std::stringstream iregs2;
    iregs2 << ": \"+r\"(a_lo"<< print_w(limbs, 0)<<".x)";
    for (int i = 1; i < limbs; i++) iregs2 << ", \"+r\"(a_lo" << print_w(limbs, i) << print_coords(limbs, i) <<")";
    for (int i = 0; i < limbs; i++) iregs2 << ", \"+r\"(a_hi" << print_w(limbs, i) << print_coords(limbs, i) <<")";
    iregs2 << ", \"+r\"(overflow)";
    wrap(iregs2.str().c_str());

    /*std::stringstream oregs;
    oregs << "\n\t: \"r\"(_b[0])";
    for (int i = 1; i < limbs; i++) oregs << ", \"r\"(_b[" << i << "])";
    for (int i = 0; i < limbs; i++) oregs << ", \"r\"(_c[" << i << "])";
    oregs << ");\n";
    wrap(oregs.str().c_str());
    cout << "}\n\n";*/

    std::stringstream oregs2;
    oregs2 << "\n\t: \"r\"(b"<< print_w(limbs, 0)<<".x)";
    for (int i = 1; i < limbs; i++) oregs2 << ", \"r\"(b" << print_w(limbs, i) << print_coords(limbs, i) <<")";
    for (int i = 0; i < limbs; i++) oregs2 << ", \"r\"(c" << print_w(limbs, i) << print_coords(limbs, i) <<")";
    oregs2 << ");\n";
    wrap(oregs2.str().c_str());
    cout << "}\n\n";
}

void propagate_q(int i, int limbs, bool c, int * state, vector< vector< pair<int,int> > > & pairs)
{
    bool cc = DO_CARRY_OUT(i);
    sprintf(r0, "%%%u", GET_DEST_REG_Q(i));
    //if (!c) cout << "\n";

    if (pairs[i].empty())
    {
	printf("\t\"add%s%s.u32\t%3s,%3s,  0    ;\\n\\t\"", CARRY_IN_FLAG(c), CARRY_OUT_FLAG(i), r0, (IS_OCCUPIED(i) ? r0 : "  0"));
	printf("\t//%3s%s= c", &(*r0='r'), (IS_OCCUPIED(i) ? "+" : " ")); 
	CARRY_IN(i);
    }
    else
    {
	auto p = pairs[i].back();
	pairs[i].pop_back();
	sprintf(r1, "%%%u", GET_FIRST_REG_Q(p));
	sprintf(r2, "%%%u", GET_SECOND_REG_Q(i,p));
	printf("\t\"mad%s%s%s.u32\t%3s,%3s,%3s,%3s;\\n\\t\"", CARRY_IN_FLAG(c), LO_OR_HI(p), CARRY_OUT_FLAG(i), r0, r1, r2, (IS_OCCUPIED(i) ? r0 : "  0"));
	printf("\t//%3s%s=[%3s*%3s]%s%s", &(*r0='r'), (IS_OCCUPIED(i) ? "+" : " "), &(*r1='r'), &(*r2='r'), LO_OR_HI(p), (c ? "+c" : "  "));
	MUL_IN(i);
    }
    if (i < limbs - 1) cout << " (r" << (i - limbs + 1) << "=>r" << GET_DEST_REG_Q(i) << ")";
    cout << "\n";
    if (cc && i < 2 * limbs - 1) propagate_q(i + 1,limbs, true, state, pairs);
}

inline void print_get_q(int limbs)
{
    int * state = new int[2 * limbs];
    vector< vector< pair<int,int> > > pairs(2 * limbs);

    for (int i = 0; i < 2 * limbs; ++i)
    {
    	state[i] = 0;
	for (int j = 0; j <= i; j++)
	{
	    if (i - j < limbs - 1 && j < limbs)
	    {
		if (i == 0 && j == 0) continue;
		pairs[i].push_back(make_pair(LO, j));
		pairs[i+1].push_back(make_pair(HI, j));
	    }
	}
    }

    cout << "__device__ __forceinline__ uintXp<uint" << BITS_IN(limbs-1) << "> get_q(const uint" << BITS_IN(limbs-1) << " & a_lo,\n\tconst uint" << BITS_IN(limbs-1) << " & a_hi, const uintXp<uint" << BITS_IN(limbs-1) << "> & mu)\n";
    cout << "{\n";
    for (int i = 0; i < NUM_TMP_REGS; i++) cout << "    uint __attribute__((unused)) tmp" << i << ";\n";
    cout << "    uintXp<uint" << BITS_IN(limbs-1) << "> q = {0};\n";
    /*cout << "    uint * _q = (uint *)&q;\n";
    cout << "    uint * _a_lo = (uint *)&a_lo;\n";
    cout << "    uint * _a_hi = (uint *)&a_hi;\n";
    cout << "    uint * _mu = (uint *)&mu;\n";*/

    auto p = make_pair(1,0);
    sprintf(r0, "%%%u", GET_DEST_REG_Q(1));
    sprintf(r1, "%%%u", GET_FIRST_REG_Q(p));
    sprintf(r2, "%%%u", GET_SECOND_REG_Q(1,p));
    printf("    asm(\"mul.hi.u32\t%3s,%3s,%3s    ;\\n\\t\"", r0, r1, r2);
    printf("\t//%3s =[%3s*%3s].hi  ", &(*r0='r'), &(*r1='r'), &(*r2='r'));
    cout << " (r" << (2-limbs) << "=>r" << GET_DEST_REG_Q(1) <<  ")\n";
    MUL_IN(1);

    for (int i = 0; i < 2 * limbs; i++)
    {
	while (!pairs[i].empty())
	{
	    propagate_q(i, limbs, false, state, pairs);
	}
    }

    // handle the implicit 1-word
    sprintf(r0, "%%%u", GET_DEST_REG_Q(limbs-1));
    sprintf(r1, "%%%u", limbs+NUM_TMP_REGS);
    sprintf(r2, "%%%u", 3*limbs+NUM_TMP_REGS-1);
    printf("\t\"mad.lo.cc.u32\t%3s,%3s,%3s,%3s;\\n\\t\"",r0,r1,r2,r0);
    printf("\t//%3s+=%3s*%3s\n", &(*r0='r'), &(*r1='r'), &(*r2='r'));
    for (int i = 1; i < limbs - 1; i++)
    {
	sprintf(r0, "%%%u", GET_DEST_REG_Q(limbs-1+i));
	sprintf(r1, "%%%u", limbs+NUM_TMP_REGS+i);
	sprintf(r2, "%%%u", 3*limbs+NUM_TMP_REGS-1);
	printf("\t\"madc.lo.cc.u32\t%3s,%3s,%3s,%3s;\\n\\t\"",r0,r1,r2,r0);
	printf("\t//%3s+=%3s*%3s+c\n", &(*r0='r'), &(*r1='r'), &(*r2='r'));
    }
    sprintf(r0, "%%%u", GET_DEST_REG_Q(2 * limbs - 2));
    sprintf(r1, "%%%u", 2*limbs-1+NUM_TMP_REGS);
    sprintf(r2, "%%%u", 3*limbs+NUM_TMP_REGS-1);
    printf("\t\"madc.lo.cc.u32\t%3s,%3s,%3s,%2s;\\n\\t\"",r0,r1,r2,r0);
    printf("\t//%3s+=%3s*%3s+c\n", &(*r0='r'), &(*r1='r'), &(*r2='r'));
    sprintf(r0, "%%%u", GET_DEST_REG_Q(2 * limbs - 1));
    printf("\t\"addc.u32\t%3s,%3s,  0    ;\\n\\t\"", r0, r0);
    printf("\t//%3s+=c\n", &(*r0='r'));


    /*std::stringstream iregs;
    iregs << "\t: \"+r\"(_q[0])";
    for (int i = 1; i < limbs; i++) iregs << ", \"=r\"(_q[" << i << "])";
    for (int i = 0; i < NUM_TMP_REGS; i++) iregs << ", \"=r\"(tmp" << i << ")";
    wrap(iregs.str().c_str());*/

    std::stringstream iregs2;
    iregs2 << "\t: \"+r\"(q.lo"<< print_w(limbs-1, 0)<<".x)";
    for (int i = 1; i < limbs-1; i++) iregs2 << ", \"=r\"(q.lo" << print_w(limbs-1, i) << print_coords(limbs-1, i) <<")";
    iregs2 << ", \"=r\"(q.hi)";
    for (int i = 0; i < NUM_TMP_REGS; i++) iregs2 << ", \"=r\"(tmp" << i << ")";
    wrap(iregs2.str().c_str());


    /*std::stringstream oregs;
    oregs << "\n\t: \"r\"(_a_lo[" << (limbs-2) << "])";
    for (int i = 0; i < limbs-1; i++) oregs << ", \"r\"(_a_hi[" << i << "])";
    for (int i = 0; i < limbs; i++) oregs << ", \"r\"(_mu[" << i << "])";
    oregs << ");\n\n";
    wrap(oregs.str().c_str());
    cout << "    return q;\n";
    cout << "}\n\n";*/

    std::stringstream oregs2;
    oregs2 << "\n\t: \"r\"(a_lo" << print_w(limbs-1,limbs-2) << print_coords(limbs-1, limbs-2) <<" )";
    for (int i = 0; i < limbs-1; i++) oregs2 << ", \"r\"(a_hi" << print_w(limbs-1, i) << print_coords(limbs-1, i) <<")";
    for (int i = 0; i < limbs-1; i++) oregs2 << ", \"r\"(mu.lo" << print_w(limbs-1, i) << print_coords(limbs-1, i) <<")";
    oregs2 << ", \"r\"(mu.hi)";
    oregs2 << ");\n\n";
    wrap(oregs2.str().c_str());
    cout << "    return q;\n";
    cout << "}\n\n";

    delete [] state;
}

void propagate_r2(int i, int limbs, bool c, int * state, vector< vector< pair<int,int> > > & pairs)
{
    bool cc = DO_CARRY_OUT(i);
    sprintf(r0, "%%%u", i);
    //if (!c) cout << "\n";
    auto p = pairs[i].back();
    pairs[i].pop_back();
    sprintf(r1, "%%%u", GET_FIRST_REG_R(p));
    sprintf(r2, "%%%u", GET_SECOND_REG_R(i,p));
    printf("\"mad%s%s%s.u32\t%3s,%3s,%3s,%3s;\\n\\t\"", CARRY_IN_FLAG(c), LO_OR_HI(p), CARRY_OUT_FLAG(i), r0, r1, r2, (IS_OCCUPIED(i) ? r0 : "  0"));
    printf("\t//%3s%s=[%3s*%3s]%s%s\n\t", &(*r0='r'), (IS_OCCUPIED(i) ? "+" : " "), &(*r1='r'), &(*r2='r'), LO_OR_HI(p), (c ? "+c" : "  "));
    MUL_IN(i);
    if (cc && i < limbs - 1) propagate_r2(i + 1, limbs, true, state, pairs);
}

inline void print_get_r2(uint limbs)
{
    int * state = new int[limbs+1];
    vector< vector< pair<int,int> > > pairs(limbs+1);

    for (int i = 0; i < limbs; ++i)
    {
	state[i] = 0;
	for (int j = 0; j <= limbs-i; j++)
	{
	    pairs[i+j].push_back(make_pair(LO, j));
	    if ((i+j) < limbs) pairs[i+j+1].push_back(make_pair(HI, j));
	}
    }
    state[limbs] = 0;

    cout << "__device__ __forceinline__ uintXp<uint" << BITS_IN(limbs) << "> get_r2(const uintXp<uint" << BITS_IN(limbs) << "> & q,\n\tconst uint" << BITS_IN(limbs) << " & modulus)\n";
    cout << "{\n";
    cout << "    uintXp<uint" << BITS_IN(limbs) << "> r = {0};\n";
    /*cout << "    uint * _r = (uint *)&r;\n";
    cout << "    uint * _q = (uint *)&q;\n";
    cout << "    uint * _m = (uint *)&modulus;\n\n";*/

    cout << "    asm(";    
    for (int i = 0; i <= limbs; i++)
    {
	while (!pairs[i].empty())
	{
	    propagate_r2(i, limbs+1, false, state, pairs);
	}
    }

    /*std::stringstream iregs;
    iregs << ": \"+r\"(_r[0])";
    for (int i = 1; i <= limbs; i++) iregs << ", \"=r\"(_r[" << i << "])";
    wrap(iregs.str().c_str());*/

    std::stringstream iregs2;
    iregs2 << ": \"+r\"(r.lo"<< print_w(limbs, 0)<<".x)";
    for (int i = 1; i < limbs; i++) iregs2 << ", \"=r\"(r.lo" << print_w(limbs, i) << print_coords(limbs, i) <<")";
    iregs2 << ", \"=r\"(r.hi)";
    wrap(iregs2.str().c_str());

    /*std::stringstream oregs;
    oregs << "\n\t: \"r\"(_q[0])";
    for (int i = 1; i <= limbs; i++) oregs << ", \"r\"(_q[" << i << "])";
    for (int i = 0; i < limbs; i++) oregs << ", \"r\"(_m[" << i << "])";
    oregs << ");\n\n";
    wrap(oregs.str().c_str());
    cout << "    return r;\n";
    cout << "}\n\n";*/

    std::stringstream oregs2;
    oregs2 << "\n\t: \"r\"(q.lo"<< print_w(limbs, 0)<<".x)";
    for (int i = 1; i < limbs; i++) oregs2 << ", \"r\"(q.lo" << print_w(limbs, i) << print_coords(limbs, i) <<")";
    oregs2 << ", \"r\"(q.hi)";
    for (int i = 0; i < limbs; i++) oregs2 << ", \"r\"(modulus" << print_w(limbs, i) << print_coords(limbs, i) <<")";
    oregs2 << ");\n\n";
    wrap(oregs2.str().c_str());
    cout << "    return r;\n";
    cout << "}\n\n";


    delete [] state;
}

int main(int argc, char ** argv)
{
    char * endptr = NULL;

    uint limbs = (argc > 1) ? strtoul(argv[1], &endptr, 10) : 0;

    if (argc != 2 || *endptr != '\0')
    {
    	cout << "Usage: " << argv[0] << " LIMBS > uintX.h\n\n";
    	return -1;
    }
    if (limbs < 2)
    {
    	cout << "Error: number of limbs must be at least 2\n\n";
    	return -1;
    }

    r0 = new char[8];
    r1 = new char[8];
    r2 = new char[8];
    r3 = new char[8];

    print_license();

    cout << "#ifndef __UINT_" << BITS_IN(limbs) << "_H\n";
    cout << "#define __UINT_" << BITS_IN(limbs) << "_H\n";
    cout << "#include \"uint.h\"\n\n";

    if (limbs > 4) print_uint(limbs);
    cout << "#ifndef __UINTX__\n";
    cout << "#define __UINTX__\n";
    cout << "    typedef uint" << BITS_IN(limbs) << " uintX;\n";
    cout << "#endif\n\n";

    cout << "#define LIMBS_PER_UINTX " << limbs << "\n\n";

    //print_make_uint(limbs);
    print_to_ZZ(limbs);
    print_to_ZZ_p(limbs);
    print_to_uint(limbs);

    print_normalize(limbs);
    print_sub(limbs);
    print_get_q(limbs+1);
    print_get_r2(limbs);
    print_sub_modulus(limbs);
    print_mad(limbs);

    cout << "#endif\n";

    delete [] r0;
    delete [] r1;
    delete [] r2;
    delete [] r3;

    return 0;
}
